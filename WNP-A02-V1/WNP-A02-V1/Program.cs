//
// Demonstrates simple asynchronous TCPIP Client and Server
//
// Code base partially generated by ChatGPT.
//

using System;
using System.ComponentModel.Design;
using System.Net;
using System.Net.Sockets;
using System.Reflection.PortableExecutable;
using System.Runtime.InteropServices;
using System.Runtime.Serialization.Formatters;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;

namespace WNPA02V1
{
    class WNPA02V1
    {
        private static string[] data = new string[16];
        public static async Task Main()
        {
            string[] response;
            response = ReadFileAsync();
            // Create the TcpListener and start it
            TcpListener listener = new TcpListener(IPAddress.Parse("10.10.117.211"), 5000);
            listener.Start();
            Console.WriteLine("Server started on port 5000");

            
            // Main loop to handle client requests.
            // The server accepts a client request, then passes control
            //    to the code that does the work.

            while (true)
            {
                TcpClient client = await listener.AcceptTcpClientAsync();

                
                Task task = HandleClientAsync(client);
            }
        }

        // The client handler handles the request
        private static async Task HandleClientAsync(TcpClient client)
        {
            Console.WriteLine("Client connected");

            // The using statement should be used to make communications
            //   easier.
            using NetworkStream stream = client.GetStream();

            // Need a buffer for the input
            byte[] buffer = new byte[1024];


            while (true)
            {
                int bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length);

                // Remember, the data over TCP/IP is in bytes, so the stream
                //    must be converted to a string so you can use it.
                //string message = Encoding.UTF8.GetString(buffer, 0, bytesRead);
                string message = Encoding.UTF8.GetString(buffer, 0, bytesRead);

                Console.WriteLine($"Received: {message}");

                int code = determine_response(message);

                // The data must be converted to a byte array to be used
                //    by TCP/IP

                string info;
                if (code == 0){
                    info = "|Jumble";
                }
                else
                {
                    info = "|Found";
                }
               string response = data[code] + info;
                byte[] responseBytes = Encoding.UTF8.GetBytes(response);

                await stream.WriteAsync(responseBytes, 0, responseBytes.Length);
                Console.WriteLine("Response sent");
            }
            //later on we cn specify which client disconnected here 
            Console.WriteLine("Client disconnected");
            client.Close();
        }


        private static int determine_response(string message)
        {
            int code = 0;
            if (message == "Hello from client!")
            {
                code = 0;
            }
            else
            {
                for (int i = 2; i < 15; i++)
                {
                    if (message == data[i] ) {
                        code = i;
                    }
                }
            }
             return code;
        }


        private static string[] ReadFileAsync()
        {
            string line;
            string filepath = @"E:\SRC\WNP\WNP-A02\WNP-A02\WNP-A02-V1\WNP-A02-V1\GameData\data01.txt";
            // string[] data = new string[16];

            using StreamReader sr = new StreamReader(filepath);

            int i = 0;

            while ((line = sr.ReadLine()) != null && i < 16)
            {
                data[i] = line;
                i++;  // move to next index for next line
            }

            //close the file
            sr.Close();
            //Console.ReadLine();
            Console.WriteLine(data[0]);
            return data;
        }
    }
}
